(function(args) {
	'use strict';

	var expose = args.expose;
	var markdown = args.markdown;
	var typogr = args.typogr;
	var renderJsonML = args.renderJsonML;

	// Do substitution after smartypants has run.
	// Need to use named entities, because MeFi simply strips numeric entities.
	function replaceNumericEntities(htmlText) {
		return htmlText.replace( /&#34;/g,		'&quot;' )
		    		   .replace( /&#39;/g,		'&apos;' )
		    		   .replace( /&#8211;/g,	'&ndash;' )
		    		   .replace( /&#8212;/g,	'&mdash;' )
		    		   .replace( /&#8216;/g,	'&lsquo;' )
		    		   .replace( /&#8217;/g,	'&rsquo;' )
		    		   .replace( /&#8220;/g,	'&ldquo;' )
		    		   .replace( /&#8221;/g,	'&rdquo;' )
		    		   .replace( /&#8230;/g,	'&hellip;');
	}

	expose.md2html = function(markdownText) {
		var markdownTree = markdown.parse(markdownText);
		var htmlTree = markdown.toHTMLTree(markdownTree);
		//console.log(htmlTree);
		var htmlText = renderJsonML.renderJsonML(htmlTree);

		var smartHtmlText = typogr.smartypants(htmlText);
		smartHtmlText = replaceNumericEntities(smartHtmlText);

		return smartHtmlText;
	};

	// Return the number of the next link reference.
	// Use this for the auto-numbering links, that are
	// generated by the Link button.
	expose.nextLinkNumber = function(markdownText) {
		var markdownTree = markdown.parse(markdownText);
		//console.log(markdownTree);

		if (markdownTree.length >= 2 &&
			markdownTree[0] === 'markdown' &&
			typeof(markdownTree[1] === 'object') &&
			('references' in markdownTree[1]) ) {

			var references = markdownTree[1].references;
			var referenceNumbers =
				Object.keys(references)
				.map(function(x) { return parseInt(x, 10); })
				.filter(function(x) { return !isNaN(x); });
			//console.log(referenceNumbers)
			var largestReferenceNumber = Math.max.apply(null, referenceNumbers);
			//console.log(largestReferenceNumber);

			// If there are no numeric references, max() returns -Infinity.
			if (largestReferenceNumber < 1) {
				return 1;
			}
			else {
				return largestReferenceNumber + 1;
			}
		}
		else {
			return 1;
		}

		//console.log(markdownTree);
	};

})( (function() {
  if ( typeof exports === "undefined" ) {
    window.md4mefi = {};
    return {
    	expose: window.md4mefi,
    	markdown: window.markdown,
    	typogr: window.typogr,
    	renderJsonML: window.renderJsonML,
    };
  }
  else {
    return {
    	expose: exports,
    	// When used through npm, markdown adds another layer of indirection, 
    	// hence the .markdown at the end.
		markdown: require( "markdown" ).markdown,
		typogr: require('typogr'),
		renderJsonML: require('./renderJsonML'),
    };
  }
} )() );