(function(args) {
	'use strict';

	var expose = args.expose;
	var markdown = args.markdown;
	var typogr = args.typogr;
	var renderJsonML = args.renderJsonML;

	var marked = require('marked');

	expose.mangleTokenNewlines = function(tokens) {
		var rules = [
			// if currToken...	is followed by nextToken, then add a newline
			['paragraph', 		'paragraph'],
			['paragraph',		'blockquote_start'],
			['paragraph', 		'list_start'],
			// TODO: does list_end even have a text node? 
			// get rid of this entry?
			['list_end',		'paragraph'],
			['code',			'paragraph'],
			['paragraph',		'code'],
		];
		var currTokenIdx, currToken, nextToken;
		for (currTokenIdx = 0; currTokenIdx < tokens.length - 1; currTokenIdx++) {
			currToken = tokens[currTokenIdx];
			nextToken = tokens[currTokenIdx + 1];

			rules.forEach(function(rule) {
				if (currToken.type === rule[0] && nextToken.type === rule[1]) {
					console.log("Mangling: " + rule[0] + "\t" + rule[1]);
					currToken.text += "\n\n";
				}
			});
		}

		return tokens;
	};

	var makeRenderer = function() {
		var renderer = new marked.Renderer();
		var wrappedRenderer = new marked.Renderer();

		renderer.paragraph = function(text) {
			// Return bare text, no surrounding <p> tags
			// This works because we've mangled the tokens
			// to add newlines.
			return text;
		};

		renderer.code = function(code, language, escaped) {
			var endsInNewline = false;
			if (code.search(/\n\n$/) !== -1){
				code = code.replace(/\n\n$/, '');
				endsInNewline = true;
			}

			var output = wrappedRenderer.code(code, language, escaped);
			if (endsInNewline) {
				output += "\n\n";
			}

			return output;
		}

		renderer.list = function(body, ordered) {
			// Lists should have two trailing newlines, not just one
			var html = wrappedRenderer.list(body, ordered);
			return html + "\n";
		}

		renderer.blockquote = function(quote) {
			// The blockquote ends in one newlines, we want it to
			// end in two.
			var html = wrappedRenderer.blockquote(quote);
			return html + "\n";
		}

		return renderer;
	};

	expose.md2html = function(markdownText) {
		var tokens = marked.lexer(markdownText);
		console.log();
		console.log("Before mangling:");
		console.log(tokens);
		tokens = expose.mangleTokenNewlines(tokens);
		console.log("After mangling:");
		console.log(tokens);

		// var renderer = new marked.Renderer();
		// renderer.paragraph = function(text) {
		// 	// Return bare text, no surrounding <p> tags
		// 	// This works because we've mangled the tokens
		// 	// to add newlines.
		// 	return text;
		// };
		var renderer = makeRenderer();
		var parserOptions = {
			renderer: renderer,
			// TODO: Give smartypants another try. I think I
			// activated it in the wrong spot, and it never
			// actually turned on.
		};
		var parser = new marked.Parser(parserOptions);
		var parsed = parser.parse(tokens);

		// console.log();
		// console.log("------");
		// console.log(parsed);		
		// console.log("------");

		// Remove any trailing double newlines.
		parsed = parsed.replace(/\n\n$/, "");

		return parsed;
	}


	// // Do substitution after smartypants has run.
	// // Need to use named entities, because MeFi simply strips numeric entities.
	// function replaceNumericEntities(htmlText) {
	// 	return htmlText.replace( /&#34;/g,		'&quot;' )
	// 	    		   .replace( /&#39;/g,		'&apos;' )
	// 	    		   .replace( /&#8211;/g,	'&ndash;' )
	// 	    		   .replace( /&#8212;/g,	'&mdash;' )
	// 	    		   .replace( /&#8216;/g,	'&lsquo;' )
	// 	    		   .replace( /&#8217;/g,	'&rsquo;' )
	// 	    		   .replace( /&#8220;/g,	'&ldquo;' )
	// 	    		   .replace( /&#8221;/g,	'&rdquo;' )
	// 	    		   .replace( /&#8230;/g,	'&hellip;');
	// }

	// expose.md2html = function(markdownText) {
	// 	var markdownTree = markdown.parse(markdownText);
	// 	var htmlTree = markdown.toHTMLTree(markdownTree);
	// 	//console.log(htmlTree);
	// 	var htmlText = renderJsonML.renderJsonML(htmlTree);

	// 	var smartHtmlText = typogr.smartypants(htmlText);
	// 	smartHtmlText = replaceNumericEntities(smartHtmlText);

	// 	return smartHtmlText;
	// };

	// Return the number of the next link reference.
	// Use this for the auto-numbering links, that are
	// generated by the Link button.
	expose.nextLinkNumber = function(markdownText) {
		var tokens = marked.lexer(markdownText);
		//console.log(tokens);

		var linkNumbers =
			Object.keys(tokens.links)
			.map(function(linkNumber) { 
				// Convert everything to base 10 integers,
				// so leading zeroes don't get treated as octal.
				return parseInt(linkNumber, 10); 
			})
			.filter(function(linkNumber) { 
				// Non-numeric link titles became NaN after parseInt()
				return !isNaN(linkNumber); 
			});
		var maxLinkNumber = Math.max.apply(null, linkNumbers);

		// If there are no numeric references, max() returns -Infinity.
		if (maxLinkNumber < 1) {
			return 1;
		}
		else {
			return maxLinkNumber + 1;
		}
	};


})( (function() {
  if ( typeof exports === "undefined" ) {
    window.md4mefi = {};
    return {
    	expose: window.md4mefi,
    	markdown: window.markdown,
    	typogr: window.typogr,
    	renderJsonML: window.renderJsonML,
    };
  }
  else {
    return {
    	expose: exports,
    	// When used through npm, markdown adds another layer of indirection, 
    	// hence the .markdown at the end.
		markdown: require( "markdown" ).markdown,
		typogr: require('typogr'),
		renderJsonML: require('./renderJsonML'),
    };
  }
} )() );