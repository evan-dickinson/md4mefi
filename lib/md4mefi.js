(function(args) {
	'use strict';

	var expose = args.expose;
	var marked = args.marked;

	// When one blockquote contains several paragraph tags,
	// wrap each paragraph in its own blockquote.
	// 
	// Do this because in an FPP, the consecutive paragraphs
	// would all get smashed together.
	var makeOneBlockquotePerPara = function(tokens) {
		var newTokens = [];
		var isInBlockquote = false;

		tokens.forEach(function(currToken, currTokenIdx) {
			newTokens.push(currToken);

			if (currTokenIdx >= tokens.length - 1) {
				return;
			}
			var nextToken = tokens[currTokenIdx + 1];

			if (currToken.type === 'blockquote_start') {
				isInBlockquote = true;
			}
			else if (currToken.type === 'blockquote_end') {
				isInBlockquote = false;
			}

			var isSubsequentParaInBlockquote =
				isInBlockquote &&
				currToken.type === 'paragraph' &&
				nextToken.type === 'paragraph';
			if (isSubsequentParaInBlockquote) {
				newTokens.push({
					type: 'blockquote_end'
				});
				newTokens.push({
					type: 'blockquote_start'
				});
			}
		});

		newTokens.links = tokens.links;
		return newTokens;
	};

	expose.mangleTokenNewlines = function(tokens) {
		var rules = [
			// if currToken...	is followed by nextToken, then add a newline
			['paragraph', 		'paragraph'],
			['paragraph',		'blockquote_start'],
			['paragraph', 		'list_start'],
			// TODO: does list_end even have a text node? 
			// get rid of this entry?
			['list_end',		'paragraph'],
			['code',			'paragraph'],
			['code',			'list_start'],
			['paragraph',		'code'],
		];
		var currTokenIdx, currToken, nextToken;
		tokens.forEach(function(currToken, currTokenIdx) {
			if (currTokenIdx >= tokens.length - 1) {
				return;
			}
			nextToken = tokens[currTokenIdx + 1];

			rules.forEach(function(rule) {
				if (currToken.type === rule[0] && nextToken.type === rule[1]) {
					//console.log("Mangling: " + rule[0] + "\t" + rule[1]);
					currToken.text += "\n\n";
				}
			});
		});

		return tokens;
	};

	var makeRenderer = function() {
		var renderer = new marked.Renderer();
		var wrappedRenderer = new marked.Renderer();

		renderer.paragraph = function(text) {
			// Return bare text, no surrounding <p> tags
			// This works because we've mangled the tokens
			// to add newlines.
			return text;
		};

		renderer.code = function(code, language, escaped) {
			var endsInNewline = false;
			if (code.search(/\n\n$/) !== -1){
				code = code.replace(/\n\n$/, '');
				endsInNewline = true;
			}

			var output = wrappedRenderer.code(code, language, escaped);
			if (endsInNewline) {
				output += "\n\n";
			}

			return output;
		};

		renderer.list = function(body, ordered) {
			// Lists should have two trailing newlines, not just one
			var html = wrappedRenderer.list(body, ordered);
			return html + "\n";
		};

		renderer.blockquote = function(quote) {
			// The blockquote ends in one newlines, we want it to
			// end in two.
			var html = wrappedRenderer.blockquote(quote);
			return html + "\n";
		};

		return renderer;
	};

	expose.md2html = function(markdownText) {
		var tokens = marked.lexer(markdownText);


		// console.log();
		// console.log("Before fixing blockquotes:");
		// console.log(tokens);	
		tokens = makeOneBlockquotePerPara(tokens);

		// console.log();
		// console.log("Before mangling:");
		// console.log(tokens);		
		tokens = expose.mangleTokenNewlines(tokens);

		// console.log("After mangling:");
		// console.log(tokens);

		var renderer = makeRenderer();
		var parserOptions = {
			renderer: renderer,
			smartypants: true,
			gfm: true,
		};
		var parser = new marked.Parser(parserOptions);
		var htmlText = parser.parse(tokens);

		// console.log();
		// console.log("------");
		// console.log(parsed);		
		// console.log("------");

		// Remove any trailing double newlines.
		htmlText = htmlText.replace(/\n\n$/, "");

		var encodedHtml = encodeSmartypants(htmlText);
		return encodedHtml;
	};

	// marked does its smartypants substitution with unicode
	// characters. Turn those into HTML entities.
	function encodeSmartypants(htmlText) {
		return htmlText.replace(/\u2018/g, '&lsquo;')
					   .replace(/\u2019/g, '&rsquo;')
					   .replace(/\u201C/g, '&ldquo;')
					   .replace(/\u201D/g, '&rdquo;')
					   .replace(/\u2013/g, '&ndash;')
					   .replace(/\u2014/g, '&mdash;')
					   .replace(/\u2026/g, '&hellip;');
	}

	// Return the number of the next link reference.
	// Use this for the auto-numbering links, that are
	// generated by the Link button.
	expose.nextLinkNumber = function(markdownText) {
		var tokens = marked.lexer(markdownText);
		//console.log(tokens);

		var linkNumbers =
			Object.keys(tokens.links)
			.map(function(linkNumber) { 
				// Convert everything to base 10 integers,
				// so leading zeroes don't get treated as octal.
				return parseInt(linkNumber, 10); 
			})
			.filter(function(linkNumber) { 
				// Non-numeric link titles became NaN after parseInt()
				return !isNaN(linkNumber); 
			});
		var maxLinkNumber = Math.max.apply(null, linkNumbers);

		// If there are no numeric references, max() returns -Infinity.
		if (maxLinkNumber < 1) {
			return 1;
		}
		else {
			return maxLinkNumber + 1;
		}
	};


})( (function() {
  if ( typeof exports === "undefined" ) {
    window.md4mefi = {};
    return {
    	expose: window.md4mefi,
    	marked: window.marked,
    };
  }
  else {
    return {
    	expose: exports,
    	marked: require('marked'),
    };
  }
} )() );